# Erlang虚拟机的消息队列机制

---

<img src="/res/erlang-logo.png" align="right">

## 目录

* [消息队列](#消息队列)
* [单进程内部的消息处理](#单进程内部的消息处理)
* [多进程的消息传递](#多进程的消息传递)
* [多进程的调度模式](#多进程的调度模式)

## [消息队列](#目录)

<img src="/res/mq.jpg" align="right">

* 在Erlang的虚拟机(BEAM)里，对进程内的消息处理机制是一种常见的**队列(queue)结构**，也就是**先进先出**，这也是大多数进程处理的模式。所以丢到工作队列的作业，会按照先后顺序进行执行。

* 我们程序内部的消息传递机制，大部分是采用了**OTP**中的**GenServer**模式，所以在消息处理的队列中，每一次发送的GenServer消息，都会按照队列的先后顺序进行处理。

* 如上所说，因为每一个消息都会按照队列顺序进行处理，所以当有一连串的GenServer消息发送到队列的时候，且他们都是对同一字段的数据进行修改时，就需要考虑到后面的消息里面的data有没有被前一次的消息更新。

## [单进程内部的消息处理](#目录)

* 从单进程来看，消息队列就是一个很简易的队列模型，即先进先出。当有消息堆积时，先进入的消息，会被先处理。

* 这种单进程内部的消息队列是没有优先级的，即数据计算和消息事件都是同一优先级。所以在服务器端，如果我们希望将事件优先发送时(避免服务器端的事件拥塞、同时发送)，我们就需要对同一玩家采用多进程模式。也就是常见的Session和Avatar。其中Session的主要目的就是和客户端收发消息。

## [多进程的消息传递](#目录)

* 从多进程的角度来看，首先，进程之间的消息传递，我们采用的是**OTP**中的**GenServer**。

* 在代码中，最常见的两个进程就是Session和Avatar，当然也包含一些其他的模块，也采用了GenServer，比如(Activity.Mgr.Server Cluster Family.Server等)。

## [多进程的调度模式](#目录)

<img src="/res/mq-high.jpg" align="right">

* 对于多进程的消息处理，BEAM采用了**优先级轮转调度(reduction-counting)**，即进程之间如果优先级相同，则是轮流执行的，并允许将一定量的进程进行优先处理(即获得更多的运算时间)。

---
